---
title: 'Example: logistic regression'
author: "Sara Stoudt"
date: "April 8, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Logistic Regression example

Now we will explore a more realistic scenario and show how to change some of the default parameters. 

```{r}
library("MCMCmaxlik")
```

NIMBLE uses the BUGS language to specify a hierarchical model.

```{r model}
logRegCode <- nimbleCode({
  beta0 ~ dnorm(0, sd=10000)
  beta1 ~ dnorm(0, sd=10000)
  sigma_RE ~ dunif(0, 1000)
  for(i in 1:N) {
    beta2[i] ~ dnorm(0, sd=sigma_RE)
    logit(p[i]) <- beta0 + beta1 * x[i] + beta2[i]
    r[i] ~ dbin(p[i], n[i])
  }
})

logRegConstants <- list(N=10)

logRegData <- list(
  r=c(10, 23, 23, 26, 17, 5, 53, 55, 32, 46),
  n=c(39, 62, 81, 51, 39, 6, 74, 72, 51, 79),
  x=c(0,  0,  0,  0,  0,  1, 1,  1,  1,  1)
)

logRegInits <- list(beta0=0, beta1=0, sigma_RE=1)

logreg <- nimbleModel(code=logRegCode, constants=logRegConstants, 
                      data=logRegData, inits=logRegInits, check=FALSE)

paramNodesLogreg <- logreg$getNodeNames(topOnly=T)
Clogreg <- compileNimble(logreg)
```


## Running the algorithms

First, we compile the algorithms in NIMBLE using `buildMCMCmaxlik()`.

```{r compile}
compiledFunsLogReg <- buildMCMCmaxlik(logreg, paramNodesLogreg)
```

Then we can run the algorithms using `computeMLE()`.

First we can try different step sizes for the fixed step size approach. 

```{r algL, results="hide" }
resultsLogRegfixedL <- computeMLE(model=logreg, 
                                    paramNodes = paramNodesLogreg, 
                                    paramInit=c(10, 10),
                                    compiledFuns=compiledFunsLogReg,
                                    stepsize=.5,
                                    method="fixed")

# Warning: in nimArr_2_ManyModelAccess, accessor larger than NimArr!
# |-------------|-------------|-------------|-------------|
# |-------------------------------------------------------|
# longer object length is not a multiple of shorter object lengthError in paramMatrix[iter + 1, ] <- thetaNew : 
#   number of items to replace is not a multiple of replacement length
```



```{r algS, results="hide" }
resultsLogRegfixedS <- computeMLE(model=logreg, 
                                    paramNodes = paramNodesLogreg, 
                                    paramInit=c(10, 10),
                                    compiledFuns=compiledFunsLogReg,
                                    stepsize=.005,
                                    method="fixed")

# Warning: in nimArr_2_ManyModelAccess, accessor larger than NimArr!
# |-------------|-------------|-------------|-------------|
# |-------------------------------------------------------|
# longer object length is not a multiple of shorter object lengthError in paramMatrix[iter + 1, ] <- thetaNew : 
#   number of items to replace is not a multiple of replacement length
```

```{r fixedResult}
resultsLogRegfixedL$MLE
resultsLogRegfixedS$MLE
```

%% get number of iterations

Now we can compare the default settings for the number of MCMC samples for both the gradient estimation and the 1D sampling step (numMCMCSamples=300, numMCMCSamples1D=300) with other choices of sample size for the 1D sampling method.

```{r algorithm, results="hide"}
resultsLogReg1Dsampling <- computeMLE(model=logreg, 
                                    paramNodes = paramNodesLogreg, 
                                    paramInit=c(10, 10),
                                    compiledFuns=compiledFunsLogReg,
                                    method="ga1D")

# Warning: in nimArr_2_ManyModelAccess, accessor larger than NimArr!
# |-------------|-------------|-------------|-------------|
# |-------------------------------------------------------|
# |-------------|-------------|-------------|-------------|
# |-------------------------------------------------------|
# longer object length is not a multiple of shorter object lengthError in paramMatrix[iter + 1, ] <- thetaCurr : 
#   number of items to replace is not a multiple of replacement length
```

%% need to plot this

Now let's see what happens when we decrease the number of MCMC samples in the gradient estimation step.

```{r algorithm2, results="hide"}
resultsLogReg1DsamplingSL <- computeMLE(model=logreg, 
                                    paramNodes = paramNodesLogreg, 
                                    paramInit=c(10, 10),
                                    compiledFuns=compiledFunsLogReg,
                                    numMCMCSamples=100, numMCMCSamples1D=300,
                                    method="ga1D")
# Warning: in nimArr_2_ManyModelAccess, accessor larger than NimArr!
# |-------------|-------------|-------------|-------------|
# |-------------------------------------------------------|
# |-------------|-------------|-------------|-------------|
# |-------------------------------------------------------|
# longer object length is not a multiple of shorter object lengthError in paramMatrix[iter + 1, ] <- thetaCurr : 
#   number of items to replace is not a multiple of replacement length
```

Alternatively, let's see what happens when we decrease the number of MCMC samples in the 1D sampling step. We would expect this to do worse than above.

```{r algorithm3, results="hide"}
resultsLogReg1DsamplingLS <- computeMLE(model=logreg, 
                                    paramNodes = paramNodesLogreg, 
                                    paramInit=c(10, 10),
                                    compiledFuns=compiledFunsLogReg,
                                    numMCMCSamples=300, numMCMCSamples1D=100,
                                    method="ga1D")

# Warning: in nimArr_2_ManyModelAccess, accessor larger than NimArr!
# |-------------|-------------|-------------|-------------|
# |-------------------------------------------------------|
# |-------------|-------------|-------------|-------------|
# |-------------------------------------------------------|
# longer object length is not a multiple of shorter object lengthError in paramMatrix[iter + 1, ] <- thetaCurr : 
#   number of items to replace is not a multiple of replacement length
```

```{r 1DResult}
resultsLogReg1Dsampling$MLE
resultsLogReg1DsamplingSL$MLE
resultsLogReg1DsamplingLS$MLE
```


%% make plots for this

