#' Compute the MLE given a BUGS model
#'
#' This function computes the MLE of the top-level parameters of a
#' hierarchical model with latent variables.
#' @param model a nimble model object
#' @param paramNodes a character vector indicating the top-level parameters
#' @param method a string indicating the optimization strategy
#' @param paramInit the initial starting point
#' @param compiledFuns a list of compiled function, generated by 
#' buildMCMCmaxlik()
#' @keywords MLE
#' @export
#' @examples
#' compileMLE()

computeMLE <- function(model, paramNodes, method="adam", paramInit=NULL,
                       compiledFuns=NULL, ...) {
  if(is.null(paramInit)) {
    paramInit <- rep(1, length(paramNodes))
  }
  if(!is.null(compiledFuns)) {
    switch(method,
           fixed = gaFixedMLE(model=model, paramNodes=paramNodes,
                              compiledFuns=compiledFuns, 
                              paramInit=paramInit,
                              ...),
           NR = NRMLE(model=model, paramNodes=paramNodes,
                      compiledFuns=compiledFuns, paramInit=paramInit,
                      ...),
           adagrad = adagradMLE(model=model, paramNodes=paramNodes,
                                compiledFuns=compiledFuns, 
                                paramInit=paramInit,
                                ...),
           adadelta = adadeltaMLE(model=model, paramNodes=paramNodes,
                                  compiledFuns=compiledFuns, 
                                  paramInit=paramInit,
                                  ...),
           adam = adamMLE(model=model, paramNodes=paramNodes, 
                          paramInit=paramInit,
                          compiledFuns=compiledFuns, ...),
           ga1D = ga1DMLE(model=model, paramNodes=paramNodes, 
                          paramInit=paramInit,
                          compiledFuns=compiledFuns, ...))
  }
}


# Check if the update is out of range.
checkOutOfRange <- function(thetaNew, boundary) {
  outOfRange <- F
  for (i in 1:length(thetaNew)) {
    if (thetaNew[i] < boundary[[i]][1]) {
      outOfRange <- T
      break
    }
    else if (thetaNew[i] > boundary[[i]][2]) {
      outOfRange <- T
      break
    }
  }
  return(outOfRange)
}

checkBlocks <- function(mat1, mat2, pValThreshold) {
  pVals <- sapply(1:ncol(mat1), function(j) {
    compareBlocks(mat1[, j], mat2[, j]) 
  })
  list(pass = all(pVals > pValThreshold), pVals = pVals)
}

compareBlocks <- function(seq1, seq2) {
  benchmark <- mean(seq1)
  t.test(seq2, mu = benchmark)$p.value
}

checkRuns <- function(mat, runsThreshold) {
  numRuns <- apply(mat, 2, function(seq1) {
    length(rle(diff(seq1) > 0)$lengths)
  })
  list(pass = all(numRuns >= runsThreshold), numRuns = numRuns)
}