#' Compute the MLE using Adam.
#'
#' This function computes the MLE of the top-level parameters of a
#' hierarchical model with latent variables using Adam.
#' @param model a nimble model object
#' @param paramNodes a character vector indicating the top-level parameters
#' @param compiledFuns a list of compiled function, generated by buildMCMCmaxlik()
#' @param paramInit the initial starting point
#' @param boundary the range of the top-level parameters, 
#' default to using getBound() 
#' @param postMode a boolean indicating whether to include prior in the calculation
#' @param trackEffSizeGrad a boolean indicating whether effective size of the MCMC
#' samples is checked
#' @param maxIter maximum number of iterations
#' @param numMCMCSamples MCMC sample size for gradient approximation
#' @param delta finite element differences
#' @param burninFrac the fraction of burn-in samples for gradient approximation
#' @param tol the tolerance
#' @param stepsize the step size
#' @param eps epsilon
#' @param beta1 beta1
#' @param beta2 beta2
#' @keywords MLE
#' @export
#' @examples
#' compileMLE()

adamMLE <- function(model, paramNodes, compiledFuns, paramInit,
                    boundary=NULL,
                    postMode = F, trackEffSizeGrad = F,
                    maxIter = 100, numMCMCSamples = 10000, 
                    delta = 1e-04, 
                    burninFrac = 0.5,
                    tol = 1e-04, 
                    stepsize=0.001,
                    eps = 1e-8, beta1=0.9, beta2=0.999) {
  if (is.null(boundary)) {
    boundary=vector('list',length(paramNodes))
    for(i in 1:length(paramNodes)){
      boundary[[i]] <-
        c(getBound(model,paramNodes[i],'lower'),
          getBound(model,paramNodes[i],'upper'))
    }
  }
  
  thetaCur <- paramInit
  thetaNew <- paramInit
  iter <- 1
  thr <- Inf
  paramMatrix <- matrix(nrow = maxIter + 1, ncol = length(paramInit))
  if (trackEffSizeGrad) {
    latentNodes <- model$getNodeNames(latentOnly = TRUE, stochOnly = TRUE)
    effSizesGrad <- matrix(nrow = maxIter, ncol = length(latentNodes))
  }
  accumFirst <- numeric(length(paramInit))
  accumSecond <- numeric(length(paramInit))
  paramMatrix[1, ] <- paramInit
  while (iter <= maxIter & thr > tol) {
    compiledFuns$setParams$run(paramMatrix[iter, ])
    compiledFuns$MCMC$run(numMCMCSamples)
    
    compiledFuns$computeGrad$run(delta, postMode, burninFrac)
    gradCurr <- compiledFuns$computeGrad$grad
    accumFirst <- beta1 * accumFirst + (1 - beta1) * (gradCurr)
    accumSecond <- beta2 * accumSecond + (1 - beta2) * (gradCurr^2)
    accumFirstAdj <- accumFirst / (1 - beta1^iter)
    accumSecondAdj <- accumSecond / (1 - beta2^iter)
    updateCurr <-  stepsize / (sqrt(accumSecondAdj) + eps) * accumFirstAdj
    thetaNew <- paramMatrix[iter, ] + updateCurr
    # Check boundaries. (Projected)
    if (any(is.na(thetaNew))) {
      break
    }
    for (i in 1:length(paramNodes)) {
      if (thetaNew[i] < boundary[[i]][1]) {
        thetaNew[i] = boundary[[i]][1]
      }
      else if (thetaNew[i] > boundary[[i]][2]) {
        thetaNew[i] = boundary[[i]][2]
      }
      else {
        thetaNew[i] = thetaNew[i]
      }
    }
    paramMatrix[iter + 1, ] <- thetaNew
    thr <- sum((gradCurr)^2)
    thetaCur <- thetaNew
    compiledFuns$setLatent$run(tail(as.matrix(compiledFuns$MCMC$mvSamples), 1))
    
    df <- data.frame(t(thetaCur))
    names(df) <- paramNodes
    cat(paste0("Iteration Number: ", iter, ".\n",
               "Parameter Estimates:\n"))
    print(df, row.names = FALSE)
    if (trackEffSizeGrad) {
      samplesGrad <- as.matrix(compiledFuns$MCMC$mvSamples)
      samplesGrad <- samplesGrad[(ceiling(burninFrac * numMCMCSamples) + 1):numMCMCSamples,]
      
      effSizesGrad[iter,] <- round(effectiveSize(samplesGrad), 1)
      cat(paste0("Effective Sample Size for gradient (raw, min): ", 
                 min(effSizesGrad[iter, ]), 
                 "\n")) 
    }
    iter <- iter + 1
  }
  if (trackEffSizeGrad) {
    results <- list(param = paramMatrix, iter = iter, effSizesGrad = effSizesGrad)
  } else {
    results <- list(param = paramMatrix, iter = iter)
  }
  return(results)
}