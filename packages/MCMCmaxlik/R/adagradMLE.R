#' Compute the MLE using Adagrad.
#'
#' This function computes the MLE of the top-level parameters of a
#' hierarchical model with latent variables using Adam.
#' @param model a nimble model object
#' @param paramNodes a character vector indicating the top-level parameters
#' @param compiledFuns a list of compiled function, generated by buildMCMCmaxlik()
#' @param paramInit the initial starting point
#' @param boundary the range of the top-level parameters, 
#' default to using getBound() 
#' @param postMode a boolean indicating whether to include prior in the calculation
#' @param trackEffSizeGrad a boolean indicating whether effective size of the MCMC
#' samples is checked
#' @param maxIter maximum number of iterations
#' @param numMCMCSamples MCMC sample size for gradient approximation
#' @param delta finite element differences
#' @param burninFrac the fraction of burn-in samples for gradient approximation
#' @param stepsize the step size
#' @param eps epsilon
#' @param blockSize the size of blocks for convergence checking
#' @param runsThreshold the cutoff for acceptable number of runs within a block
#' of iterates, default to one-fifth of the block size
#' @param pValsThreshold the cutoff of p-value threshold for comparing
#' averages between two blocks of iterates
#' @keywords MLE
#' @export
#' @examples
#' adagradMLE()

adagradMLE <- function(model, paramNodes, compiledFuns, paramInit, 
                       boundary=NULL,
                       postMode = F, maxIter = 100,
                       burninFrac = 0.5,
                       numMCMCSamples = 10000, 
                       eta=0.01, delta = 1e-04, eps = 1e-2,
                       tol = 1e-04,
                       blockSize = 20, runsThreshold = floor(blockSize / 5),
                       pValThreshold = 0.3) {
  
  # Determine the boundary conditions.
  if (is.null(boundary)) {
    boundary=vector('list',length(paramNodes))
    for(i in 1:length(paramNodes)){
      boundary[[i]] <-
        c(getBound(model,paramNodes[i],'lower'),
          getBound(model,paramNodes[i],'upper'))
    }
  }
  
  thetaCur <- paramInit
  thetaNew <- paramInit
  iter <- 1
  thr <- Inf
  paramMatrix <- matrix(nrow = maxIter, ncol = length(paramInit))
  accumGrad <- numeric(length(paramInit))
  paramMatrix[1, ] <- paramInit
  while (iter < maxIter & thr > tol) {
    compiledFuns$setParams$run(paramMatrix[iter, ])
    compiledFuns$MCMC$run(numMCMCSamples)
    compiledFuns$computeGrad$run(delta, postMode, burninFrac)
    gradCurr <- compiledFuns$computeGrad$grad
    accumGrad <- accumGrad + (gradCurr ^ 2)
    RMSGrad <- sqrt(accumGrad + eps)
    updateCurr <- eta / RMSGrad * gradCurr
    thetaNew <- paramMatrix[iter, ] + updateCurr
    # Check boundaries. (Projected)
    if (any(is.na(thetaNew))) {
      break
    }
    for (i in 1:length(paramNodes)) {
      if (thetaNew[i] < boundary[[i]][1]) {
        thetaNew[i] = boundary[[i]][1]
      }
      else if (thetaNew[i] > boundary[[i]][2]) {
        thetaNew[i] = boundary[[i]][2]
      }
      else {
        thetaNew[i] = thetaNew[i]
      }
    }
    paramMatrix[iter + 1, ] <- thetaNew
    thr <- sum((gradCurr)^2)
    thetaCur <- thetaNew
    compiledFuns$setLatent$run(tail(as.matrix(compiledFuns$MCMC$mvSamples), 1))
    
    # Convergence test
    if (iter > 2 * blockSize) {
      # 1. Check oscillating behaviors.
      runsResults <- checkRuns(paramMatrix[(iter - blockSize + 1):iter, ],
                               runsThreshold)
      if (runsResults$pass) {
        # 2. Check whether the average stays constant.
        blockResults <- checkBlocks(
          paramMatrix[(iter - 2 * blockSize + 1):(iter - blockSize), ],
          paramMatrix[(iter - blockSize + 1):iter, ],
          pValThreshold)
        if (blockResults$pass) {
          converge <- T
          break 
        }
      }
    }
    iter <- iter + 1
  }
  cat("*** Convergence diagnostics ***\n")
  cat(paste0("Number of runs in the last ", 
             blockSize, " iterations: ", 
             paste0(runsResults$numRuns, collapse=", "),
             "\n"))
  if (runsResults$pass) {
    cat(paste0("p-value from 2-sample t-test for block comparisons: ",
               paste(round(blockResults$pVal, 3), collapse=", "),
               "\n")) 
  }
  
  if (!converge) {
    cat("*** Warning: Non-convergence ***\n")
    cat("Use a different starting point or increase the MCMC sample size.\n")
  }
  
  return(list(param = paramMatrix, iter = iter))
}