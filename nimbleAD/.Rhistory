loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
negloglik
negloglik(rep(0.01, p)
)
negloglik(rep(0.01, p))
negloglik(rep(0.02, p))
?optim
optim(rep(1, p), negloglik, gradient)
negloglik <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
gradient <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
-1 * sapply(1:p, function(l){
-n/2 * sum(1/sigma2[1:l]) + 1/2*sum(rowSums(x^2)/sigma2^2)
})
}
optim(rep(1, p), negloglik, gradient)
optim(rep(1, p), negloglik, gradient, method="BFGS")
warnings
warnings()
negloglik <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
gradient <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
-1 * sapply(1:p, function(l){
-n/2 * sum(1/sigma2[1:l]) + 1/2*sum(colSums(x^2)/sigma2^2)
})
}
optim(rep(1, p), negloglik, gradient, method="BFGS")
warnings()
optim(rep(1, p), negloglik, gradient, lower=0.001, method="L-BFGS-B")
gen_lambda <- function(p) {
sort(runif(n=p), decreasing = T)
}
g <- function(lambda) {
4 * lambda
}
sim_x <- function(lambda) {
rnorm(length(lambda), sd=sqrt(lambda))
}
lambda <- gen_lambda(p)
x <- sapply(lambda, function(lam) {
rnorm(n, sd=sqrt(g(lam)))
})
if (is.null(dim(x))) {
x <- matrix(x, nrow=1)
}
negloglik <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
gradient <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
-1 * sapply(1:p, function(l){
-n/2 * sum(1/sigma2[1:l]) + 1/2*sum(colSums(x^2)/sigma2^2)
})
}
optim(rep(1, p), negloglik, gradient, lower=0.001, method="L-BFGS-B")
lambda <- gen_lambda(p)
x <- sapply(lambda, function(lam) {
rnorm(n, sd=sqrt(g(lam)))
})
if (is.null(dim(x))) {
x <- matrix(x, nrow=1)
}
negloglik <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
gradient <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
-1 * sapply(1:p, function(l){
-n/2 * sum(1/sigma2[1:l]) + 1/2*sum(colSums(x[1:l, ]^2)/(sigma2[1:l]^2))
})
}
optim(rep(1, p), negloglik, gradient, lower=0.001, method="L-BFGS-B")
lambda <- gen_lambda(p)
x <- sapply(lambda, function(lam) {
rnorm(n, sd=sqrt(g(lam)))
})
if (is.null(dim(x))) {
x <- matrix(x, nrow=1)
}
negloglik <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
gradient <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
-1 * sapply(1:p, function(l){
first_term <- -n/2 * sum(1/sigma2[1:l])
second_term <- 0
for (j in 1:l) {
second_term <- second_term + 1/2*sum(x[, j]^2) / (sigma2[j]^2)
}
first_term + second_term
})
}
optim(rep(1, p), negloglik, gradient, lower=0.001, method="L-BFGS-B")
lambda <- gen_lambda(p)
x <- sapply(lambda, function(lam) {
rnorm(n, sd=sqrt(g(lam)))
})
if (is.null(dim(x))) {
x <- matrix(x, nrow=1)
}
negloglik <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
gradient <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
-1 * sapply(1:p, function(l){
first_term <- -n/2 * sum(1/sigma2[1:l])
second_term <- 0
for (j in 1:l) {
second_term <- second_term + 1/2*sum(x[, j]^2) / (sigma2[j]^2)
}
first_term + second_term
})
}
optim(rep(1, p), negloglik, gradient, lower=0.0001, method="L-BFGS-B")
g(lambda)
gam <- optim(rep(1, p), negloglik, gradient, lower=0.0001, method="L-BFGS-B")$par
rev(cumsum(rev(gam)))
plot(rev(cumsum(rev(gam))))
plot(g(lambda))
plot(lambda, rev(cumsum(rev(gam))))
plot(lambda, rev(cumsum(rev(gam))), type="l")
lines(lambda, g(lambda), col="red")
gen_lambda <- function(p) {
sort(runif(n=p), decreasing = T)
}
g <- function(lambda) {
4 * lambda
}
sim_x <- function(lambda) {
rnorm(length(lambda), sd=sqrt(lambda))
}
simulation <- function(p, n=1) {
lambda <- gen_lambda(p)
x <- sapply(lambda, function(lam) {
rnorm(n, sd=sqrt(g(lam)))
})
if (is.null(dim(x))) {
x <- matrix(x, nrow=1)
}
negloglik <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
gradient <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
-1 * sapply(1:p, function(l){
first_term <- -n/2 * sum(1/sigma2[1:l])
second_term <- 0
for (j in 1:l) {
second_term <- second_term + 1/2*sum(x[, j]^2) / (sigma2[j]^2)
}
first_term + second_term
})
}
gam <- optim(rep(1, p), negloglik, gradient, lower=0.0001, method="L-BFGS-B")$par
plot(lambda, rev(cumsum(rev(gam))), type="l")
lines(lambda, g(lambda), col="red")
}
simulation(p=1000)
simulation <- function(p, n=1) {
lambda <- gen_lambda(p)
x <- sapply(lambda, function(lam) {
rnorm(n, sd=sqrt(g(lam)))
})
if (is.null(dim(x))) {
x <- matrix(x, nrow=1)
}
negloglik <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
gradient <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
-1 * sapply(1:p, function(l){
first_term <- -n/2 * sum(1/sigma2[1:l])
second_term <- 0
for (j in 1:l) {
second_term <- second_term + 1/2*sum(x[, j]^2) / (sigma2[j]^2)
}
first_term + second_term
})
}
gam <- optim(rep(0.1, p), negloglik, gradient, lower=0.0001, method="L-BFGS-B")$par
plot(lambda, rev(cumsum(rev(gam))), type="l")
lines(lambda, g(lambda), col="red")
}
simulation(p=10)
simulation(p=10)
simulation(p=10)
simulation(p=10)
simulation(p=10)
simulation(p=10)
simulation(p=10)
simulation(p=50)
simulation(p=50)
simulation(p=50)
simulation(p=50)
simulation(p=50)
simulation(p=90)
simulation(p=90)
simulation(p=90)
simulation(p=90, n=30)
simulation(p=90, n=30)
simulation(p=90, n=30)
simulation(p=90, n=30)
simulation(p=90, n=30)
simulation(p=90, n=1000)
simulation(p=90, n=10)
simulation(p=90, n=10)
simulation(p=90, n=10)
simulation(p=90, n=10)
simulation(p=200, n=20)
simulation(p=200, n=20)
gen_lambda <- function(p) {
sort(runif(n=p), decreasing = T)
}
g <- function(lambda) {
lambda^2
}
sim_x <- function(lambda) {
rnorm(length(lambda), sd=sqrt(lambda))
}
simulation <- function(p, n=1) {
lambda <- gen_lambda(p)
x <- sapply(lambda, function(lam) {
rnorm(n, sd=sqrt(g(lam)))
})
if (is.null(dim(x))) {
x <- matrix(x, nrow=1)
}
negloglik <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
gradient <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
-1 * sapply(1:p, function(l){
first_term <- -n/2 * sum(1/sigma2[1:l])
second_term <- 0
for (j in 1:l) {
second_term <- second_term + 1/2*sum(x[, j]^2) / (sigma2[j]^2)
}
first_term + second_term
})
}
gam <- optim(rep(0.1, p), negloglik, gradient, lower=0.0001, method="L-BFGS-B")$par
plot(lambda, rev(cumsum(rev(gam))), type="l")
lines(lambda, g(lambda), col="red")
}
simulation(p=10)
simulation(p=100)
gen_lambda <- function(p) {
sort(runif(n=p), decreasing = T)
}
g <- function(lambda) {
lambda^2 + 2
}
sim_x <- function(lambda) {
rnorm(length(lambda), sd=sqrt(lambda))
}
simulation <- function(p, n=1) {
lambda <- gen_lambda(p)
x <- sapply(lambda, function(lam) {
rnorm(n, sd=sqrt(g(lam)))
})
if (is.null(dim(x))) {
x <- matrix(x, nrow=1)
}
negloglik <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
loglik <- 0
for (i in 1:n) {
for (j in 1:p) {
loglik <- loglik + dnorm(x[i, j], sd=sqrt(sigma2[j]), log=TRUE)
}
}
-1*loglik
}
gradient <- function(gam) {
sigma2 <- rev(cumsum(rev(gam)))
-1 * sapply(1:p, function(l){
first_term <- -n/2 * sum(1/sigma2[1:l])
second_term <- 0
for (j in 1:l) {
second_term <- second_term + 1/2*sum(x[, j]^2) / (sigma2[j]^2)
}
first_term + second_term
})
}
gam <- optim(rep(0.1, p), negloglik, gradient, lower=0.0001, method="L-BFGS-B")$par
plot(lambda, rev(cumsum(rev(gam))), type="l")
lines(lambda, g(lambda), col="red")
}
simulation(p=100)
simulation(p=100, n=10)
simulation(p=100, n=10)
simulation(p=10, n=100000)
simulation(p=10, n=1000)
simulation(p=10, n=1000)
simulation(p=10, n=1000)
simulation(p=10, n=1000)
simulation(p=100, n=1000)
simulation(p=100, n=100)
simulation(p=100, n=100)
simulation(p=100, n=10)
simulation(p=1000, n=10)
simulation(p=10000, n=20)
phi <- c(3/4, -1/4)
y <- arima.sim(model=list(ar=phi), 500)
acf(y)
theta <- c(0.73, 0.26)
z <- arima.sim(model=list(ma=theta), 500)
acf(z)
?ARMAacf
ARMAacf(ar=phi)
ARMAacf(ma=theta)
ARMAacf(ar=phi, lag.max=20)
ARMAacf(ma=theta, lag.max=20)
2/sqrt(500)
ARMAacf(ar=phi, lag.max=20)
ARMAacf(ma=theta, lag.max=20)
ARMAacf(ar=phi, ma=theta, lag.max=20)
round(ARMAacf(ar=phi, lag.max=10), 5)
round(ARMAacf(ma=theta, lag.max=10), 5)
round(ARMAacf(ar=phi, ma=theta, lag.max=10), 5)
round(ARMAacf(ar=phi, lag.max=10), 5)
round(ARMAacf(ma=theta, lag.max=10), 5)
round(ARMAacf(ar=phi, ma=theta, lag.max=10), 5)
2/sqrt(500)
pnrom(-2, 2)
pnorm(-2, 2)
?pnorm
pnorm(2) - pnorm(-2)
library("devtools")
version()
version
library("devtools")
gh_install_packages()
install.packages("githubinstall")
library("githubinstall")
gh_install_packages("nimble-dev/nimble", ref="cppDerivs_calculate")
gh_install_packages("nimble", ref="cppDerivs_calculate")
gh_install_packages("nimble", ref="cppDerivs_calculate")
?gh_install_packages
gh_install_packages("nimble-dev/nimble", ref="cppDerivs_calculate")
?install_github
install_github("nimble-dev/nimble", ref = "cppDerivs_calculate")
setwd("~/Desktop/nimbleAD/")
install("nimble/")
library("devtools")
setwd("~/Desktop/nimbleAD/")
install("nimble/")
library("devtools")
setwd("~/Desktop/nimbleAD/")
install("nimble/packages/nimble/")
library("nimble")
nimbleOptions(experimentalEnableDerivs = TRUE)
simpleCode <- nimbleCode({
x ~ dnorm(0, 1)
y ~ dnorm(x, 1)
})
simpleModel <- nimbleModel(code = simpleCode, data = list(y = 0),
inits = list(x = 1))
compileNimble(simpleModel)
returnDerivsFunction <- nimbleFunction(
setup = function(model){
},
run = function(){
outDerivsList <- nimDerivs(model$calculate(c('x','y')), wrt = 'x') returnType(ADNimbleList())
return(outDerivsList)
}
)
nimbleFunction(
setup = function(model){
},
run = function(){
outDerivsList <- nimDerivs(model$calculate(c('x','y')), wrt = 'x') returnType(ADNimbleList())
return(outDerivsList)
}
)
returnDerivsFunction <- nimbleFunction(
setup = function(model){
},
run = function(){
outDerivsList <- nimDerivs(model$calculate(c('x','y')), wrt = 'x') returnType(ADNimbleList())
return(outDerivsList)
}
)
returnDerivsFunction <- nimbleFunction(
setup = function(model){
},
run = function(){
outDerivsList <- nimDerivs(model$calculate(c('x','y')), wrt = 'x') returnType(ADNimbleList())
return(outDerivsList)
}
)
returnDerivsFunction <- nimbleFunction(
setup = function(model){
},
run = function(){
outDerivsList <- nimDerivs(model$calculate(c('x','y')), wrt = 'x') returnType(ADNimbleList())
return(outDerivsList)
}
returnDerivsFunction <- nimbleFunction(
setup = function(model){
},
run = function(){
outDerivsList <- nimDerivs(model$calculate(c('x','y')), wrt = 'x')
returnType(ADNimbleList())
return(outDerivsList)
}
)
returnDerivsSimpleModel <- returnDerivsFunction(simpleModel)
CreturnDerivsSimpleModel <- compileNimble(returnDerivsSimpleModel, project = simpleModel)
derivsList <- CreturnDerivsSimpleModel$run()
CreturnDerivsSimpleModel <- compileNimble(returnDerivsSimpleModel, project = simpleModel)
returnDerivsSimpleModel <- returnDerivsFunction(simpleModel)
CreturnDerivsSimpleModel <- compileNimble(returnDerivsSimpleModel, project = simpleModel)
simpleCode <- nimbleCode({
x ~ dnorm(0, 1)
y ~ dnorm(x, 1)
})
simpleModel <- nimbleModel(code = simpleCode, data = list(y = 0),
inits = list(x = 1))
compileNimble(simpleModel)
returnDerivsFunction <- nimbleFunction(
setup = function(model){
},
run = function(){
outDerivsList <- nimDerivs(model$calculate(c('x','y')), wrt = 'x')
returnType(ADNimbleList())
return(outDerivsList)
}
)
returnDerivsSimpleModel <- returnDerivsFunction(simpleModel)
CreturnDerivsSimpleModel <- compileNimble(returnDerivsSimpleModel, project = simpleModel)
derivsList <- CreturnDerivsSimpleModel$run()
derivsList$jacobian ## examine jacobian matrix
?nimDerivs
